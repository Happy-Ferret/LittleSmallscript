Optimization
============

Thought
-------

Usualy with Little Smallscript every message expression is translated to method calling expression like this:  
from:  

```smalltalk
Constructor method: [1] at: #one.
```

to:  

```javascript
Constructor.methodat(function () { return 1; }, 'one')
```

While it works fine when these methods (in this case Function.prototype.methodat) are defined in javascript side, it might be more desirable for users to get the following code instead:

```javascript
Constructor.prototype.one = function () { return 1; };
```

This looks more familiar to javascript coders than the above one. It also is a fraction of millisecond faster because it has no overhead for creating a call frame for function call;  

Generating code that users are familiar with is certainly a good thing. However if you strictly follow this rule, the resulting code becomes as messy as hell.  
Here is a code generated by CoffeeScript:  

```javascript
var i, res;
res = (function() {
  var _i, _results;
  _results = [];
  for (i = _i = 0; _i < 9; i = ++_i) {
    alert(i);
    _results.push(i);
  }
  return _results;
})();
```

and Here is the code that does the same thing as above; generated by Little Smallscript:  

```javascript
var res;
res = (0).to(9).do_(function (i) {
  alert(i);
  return i;
});
```

Clearly Little Smallscript wins the readability in this case.  
We have to balance between familiarity, efficiancy and readability and carefully choose what to optimize and what to left as is.

Direction
----------

Little Smallscript promotes functional proggramming style over imperative style. This often means that the use of statements should be kept minimim.  
fors and whiles should only be used for library functions, and are not for users to write.

Therefore I decided to optimize only the methods that does not require statements.

The following is a list of expressions that should be compiled to something other than a simple method invocation expression, and what the resulting code should look like:

### Object::at: ###

```smalltalk
x at: #a.
x at: someExpression.
x at: #a put: y.
```

```javascript
x.a;
x[someExpression];
x.a = y;
```

### Boolean::ifTrue: ###

```smalltalk
x ifTrue: someBlock.
x ifTrue: [exp1. exp2].
x ifTrue: someBlockA ifFalse: someBlockB.
```

```javascript
x ? someBlock() : void 0;
x ? (exp1, exp2) : void 0;
x ? someBlock1() : someBlock2();
```

### Boolean::and,or,not ###

```smalltalk
bool and: [exp, bool2]
```

```javascript
bool && exp, bool2
```

### Class definition ###

```smalltalk
| Human |

Human <- Animal subclass.

Human method: [:name |
  this at: #myname put: name
] at: #constructor.

Human method [:name |
  window alert: ('Hello ' <+> name)
] at: #talkTo
```

```javascript
var Human;
Human = (function () {
  var Human;

  Human = function (name) {
   this.myname = name;
  };

  Human.prototype.talkTo = function (name) {
    window.alert('Hello ' + name)
  };

  return Human;
});
```

This notation is derived from CoffeeScript

### Unary operator "new" ###

```smalltalk
Human new: 'Yendor'
```

```javascript
new Human('Yendor')
```
